import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  JSON: { input: any; output: any; }
};

/** Autogenerated return type of AddToCartMutation. */
export type AddToCartMutationPayload = {
  cartItem?: Maybe<CartItem>;
  errors: Array<Scalars['String']['output']>;
};

export type Cart = {
  cartItems?: Maybe<Array<CartItem>>;
  id?: Maybe<Scalars['ID']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  totalPrice?: Maybe<Scalars['Float']['output']>;
};

export type CartItem = {
  cartId: Scalars['ID']['output'];
  id: Scalars['ID']['output'];
  partOptions: Array<PartOption>;
  product: ProductDefinition;
  productId: Scalars['ID']['output'];
  quantity: Scalars['Int']['output'];
  totalPrice: Scalars['Float']['output'];
};

/** Autogenerated return type of CheckoutMutation. */
export type CheckoutMutationPayload = {
  errors: Array<Scalars['String']['output']>;
};

export type CompatibilityRule = {
  active: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  productType?: Maybe<ProductTypeDefinition>;
  productTypeId: Scalars['ID']['output'];
  requiredOption?: Maybe<PartOption>;
  requiredOptionId: Scalars['ID']['output'];
  requiringOption?: Maybe<PartOption>;
  requiringOptionId: Scalars['ID']['output'];
  ruleType: Scalars['String']['output'];
};

/** Attributes for creating a compatibility rule */
export type CreateCompatibilityRuleInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  productTypeId: Scalars['ID']['input'];
  requiredOptionId: Scalars['ID']['input'];
  requiringOptionId: Scalars['ID']['input'];
  ruleType: Scalars['String']['input'];
};

/** Autogenerated return type of CreateCompatibilityRulesMutation. */
export type CreateCompatibilityRulesMutationPayload = {
  compatibilityRule?: Maybe<CompatibilityRule>;
  errors: Array<Scalars['String']['output']>;
};

export type CreatePartCategoryInput = {
  active: Scalars['Boolean']['input'];
  name: Scalars['String']['input'];
  position?: InputMaybe<Scalars['Int']['input']>;
  productTypeId: Scalars['ID']['input'];
  required: Scalars['Boolean']['input'];
};

/** Autogenerated return type of CreatePartCategoryMutation. */
export type CreatePartCategoryMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partCategory?: Maybe<PartCategory>;
};

export type CreatePartOptionInput = {
  inStock?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  partCategoryId: Scalars['ID']['input'];
  position?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  stockQuantity?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of CreatePartOptionMutation. */
export type CreatePartOptionMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partOption?: Maybe<PartOption>;
};

export type CreatePriceRuleInput = {
  active: Scalars['Boolean']['input'];
  description: Scalars['String']['input'];
  price: Scalars['Float']['input'];
  productTypeId: Scalars['ID']['input'];
};

/** Autogenerated return type of CreatePriceRuleMutation. */
export type CreatePriceRuleMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  priceRule?: Maybe<PriceRule>;
};

export type CreateProductDefinitionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  basePrice: Scalars['Float']['input'];
  description: Scalars['String']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  preconfigured?: InputMaybe<Scalars['Boolean']['input']>;
  productSelections?: InputMaybe<Array<ProductSelectionInput>>;
  productTypeId: Scalars['ID']['input'];
};

export type CreateProductTypeDefinitionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  name: Scalars['String']['input'];
};

/** Autogenerated return type of CreateProductTypesMutation. */
export type CreateProductTypesMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  productType: ProductTypeDefinition;
};

/** Autogenerated return type of CreateProductsMutation. */
export type CreateProductsMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  product?: Maybe<ProductDefinition>;
};

/** Autogenerated return type of DeleteCompatibilityRulesMutation. */
export type DeleteCompatibilityRulesMutationPayload = {
  compatibilityRule?: Maybe<CompatibilityRule>;
  errors?: Maybe<Array<Scalars['String']['output']>>;
};

/** Autogenerated return type of DeletePartCategoryMutation. */
export type DeletePartCategoryMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partCategory?: Maybe<PartCategory>;
};

/** Autogenerated return type of DeletePartOptionMutation. */
export type DeletePartOptionMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partOption?: Maybe<PartOption>;
};

/** Autogenerated return type of DeletePriceRuleMutation. */
export type DeletePriceRuleMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  priceRule?: Maybe<PriceRule>;
};

/** Autogenerated return type of DeleteProductTypesMutation. */
export type DeleteProductTypesMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  productType?: Maybe<ProductTypeDefinition>;
};

/** Autogenerated return type of DeleteProductsMutation. */
export type DeleteProductsMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  product: ProductDefinition;
};

export type Mutation = {
  /** Add a product to the shopping cart */
  addToCart: AddToCartMutationPayload;
  /** Checkout the shopping cart */
  checkoutCart: CheckoutMutationPayload;
  createCompatibilityRule: CreateCompatibilityRulesMutationPayload;
  createPartCategory: CreatePartCategoryMutationPayload;
  createPartOption: CreatePartOptionMutationPayload;
  createPriceRule: CreatePriceRuleMutationPayload;
  createProduct: CreateProductsMutationPayload;
  createProductType: CreateProductTypesMutationPayload;
  deleteCompatibilityRule: DeleteCompatibilityRulesMutationPayload;
  deletePartCategory: DeletePartCategoryMutationPayload;
  deletePartOption: DeletePartOptionMutationPayload;
  deletePriceRule: DeletePriceRuleMutationPayload;
  deleteProduct: DeleteProductsMutationPayload;
  deleteProductType: DeleteProductTypesMutationPayload;
  updateCompatibilityRule: UpdateCompatibilityRulesMutationPayload;
  updatePartCategory: UpdatePartCategoryMutationPayload;
  updatePartOption: UpdatePartOptionMutationPayload;
  updatePriceRule: UpdatePriceRuleMutationPayload;
  updateProduct: UpdateProductsMutationPayload;
  updateProductType: UpdateProductTypesMutationPayload;
};


export type MutationAddToCartArgs = {
  productId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  selectedOptions?: InputMaybe<Scalars['JSON']['input']>;
};


export type MutationCheckoutCartArgs = {
  sessionId: Scalars['String']['input'];
};


export type MutationCreateCompatibilityRuleArgs = {
  input: CreateCompatibilityRuleInput;
};


export type MutationCreatePartCategoryArgs = {
  input: CreatePartCategoryInput;
};


export type MutationCreatePartOptionArgs = {
  input: CreatePartOptionInput;
};


export type MutationCreatePriceRuleArgs = {
  input: CreatePriceRuleInput;
};


export type MutationCreateProductArgs = {
  input: CreateProductDefinitionInput;
};


export type MutationCreateProductTypeArgs = {
  input: CreateProductTypeDefinitionInput;
};


export type MutationDeleteCompatibilityRuleArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeletePartCategoryArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeletePartOptionArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeletePriceRuleArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteProductArgs = {
  id: Scalars['ID']['input'];
};


export type MutationDeleteProductTypeArgs = {
  id: Scalars['ID']['input'];
};


export type MutationUpdateCompatibilityRuleArgs = {
  input: UpdateCompatibilityRuleInput;
};


export type MutationUpdatePartCategoryArgs = {
  input: UpdatePartCategoryInput;
};


export type MutationUpdatePartOptionArgs = {
  input: UpdatePartOptionInput;
};


export type MutationUpdatePriceRuleArgs = {
  input: UpdatePriceRuleInput;
};


export type MutationUpdateProductArgs = {
  input: UpdateProductDefinitionInput;
};


export type MutationUpdateProductTypeArgs = {
  input: UpdateProductTypeDefinitionInput;
};

export type Order = {
  cartItems?: Maybe<Array<CartItem>>;
  id?: Maybe<Scalars['ID']['output']>;
  sessionId?: Maybe<Scalars['String']['output']>;
  totalPrice?: Maybe<Scalars['Float']['output']>;
};

/** A part category in Marcus' shop */
export type PartCategory = {
  active: Scalars['Boolean']['output'];
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  partOptions: Array<PartOption>;
  position?: Maybe<Scalars['Int']['output']>;
  productType: ProductTypeDefinition;
  productTypeId: Scalars['ID']['output'];
  required: Scalars['Boolean']['output'];
};

/** Part Option for product part category */
export type PartOption = {
  id: Scalars['ID']['output'];
  inStock?: Maybe<Scalars['Boolean']['output']>;
  name: Scalars['String']['output'];
  partCategory?: Maybe<PartCategory>;
  partCategoryId: Scalars['ID']['output'];
  position: Scalars['Int']['output'];
  price: Scalars['Float']['output'];
  stockQuantity?: Maybe<Scalars['Int']['output']>;
};

/** A price rule for a product */
export type PriceRule = {
  active: Scalars['Boolean']['output'];
  description: Scalars['String']['output'];
  id: Scalars['ID']['output'];
  partOptions: Array<PartOption>;
  price: Scalars['Float']['output'];
  priceRuleAppliesTo: Scalars['String']['output'];
  productTypeId: Scalars['ID']['output'];
};

/** A product in Marcus' shop */
export type ProductDefinition = {
  active: Scalars['Boolean']['output'];
  basePrice: Scalars['Float']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  inStock: Scalars['Boolean']['output'];
  name: Scalars['String']['output'];
  preconfigured: Scalars['Boolean']['output'];
  productSelections: Array<ProductSelection>;
  productType: ProductTypeDefinition;
};

/** A product selection */
export type ProductSelection = {
  id: Scalars['ID']['output'];
  partOption: PartOption;
  productId: Scalars['ID']['output'];
};

export type ProductSelectionInput = {
  partOptionId: Scalars['ID']['input'];
  productId: Scalars['ID']['input'];
};

export type ProductTypeDefinition = {
  active: Scalars['Boolean']['output'];
  code: Scalars['String']['output'];
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['ID']['output'];
  name: Scalars['String']['output'];
  partCategories: Array<PartCategory>;
  priceRules: Array<PriceRule>;
};

/** The query root for Marcus' shop */
export type Query = {
  cart: Cart;
  compatibilityRule: CompatibilityRule;
  compatibilityRules: Array<CompatibilityRule>;
  compatibilityRulesForProductType: Array<CompatibilityRule>;
  orders: Array<Order>;
  partCategories: Array<PartCategory>;
  partCategoriesByProductTypeCode: Array<PartCategory>;
  partCategoriesByProductTypeId: Array<PartCategory>;
  partCategory: PartCategory;
  partOption: PartOption;
  partOptions: Array<PartOption>;
  partOptionsByPartCategoryId: Array<PartOption>;
  /** Preconfigured products for the homepage */
  preconfiguredProducts: Array<ProductDefinition>;
  priceRules: Array<PriceRule>;
  priceRulesForProductType: Array<PriceRule>;
  product: ProductDefinition;
  /** All product types */
  productTypes: Array<ProductTypeDefinition>;
  products: Array<ProductDefinition>;
  productsByType: Array<ProductDefinition>;
};


/** The query root for Marcus' shop */
export type QueryCartArgs = {
  sessionId: Scalars['String']['input'];
};


/** The query root for Marcus' shop */
export type QueryCompatibilityRuleArgs = {
  id: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryCompatibilityRulesForProductTypeArgs = {
  productTypeId: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryOrdersArgs = {
  sessionId?: InputMaybe<Scalars['String']['input']>;
};


/** The query root for Marcus' shop */
export type QueryPartCategoriesByProductTypeCodeArgs = {
  productTypeCode: Scalars['String']['input'];
};


/** The query root for Marcus' shop */
export type QueryPartCategoriesByProductTypeIdArgs = {
  productTypeId: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryPartCategoryArgs = {
  id: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryPartOptionArgs = {
  id: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryPartOptionsByPartCategoryIdArgs = {
  partCategoryId: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryPreconfiguredProductsArgs = {
  productType: Scalars['String']['input'];
};


/** The query root for Marcus' shop */
export type QueryPriceRulesForProductTypeArgs = {
  productTypeId: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryProductArgs = {
  id: Scalars['ID']['input'];
};


/** The query root for Marcus' shop */
export type QueryProductTypesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
};


/** The query root for Marcus' shop */
export type QueryProductsByTypeArgs = {
  productType: Scalars['String']['input'];
};

/** Attributes for updating a compatibility rule */
export type UpdateCompatibilityRuleInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  id: Scalars['ID']['input'];
  productTypeId: Scalars['ID']['input'];
  requiredOptionId: Scalars['ID']['input'];
  requiringOptionId: Scalars['ID']['input'];
  ruleType: Scalars['String']['input'];
};

/** Autogenerated return type of UpdateCompatibilityRulesMutation. */
export type UpdateCompatibilityRulesMutationPayload = {
  compatibilityRule?: Maybe<CompatibilityRule>;
  errors: Array<Scalars['String']['output']>;
};

export type UpdatePartCategoryInput = {
  active: Scalars['Boolean']['input'];
  id: Scalars['ID']['input'];
  name: Scalars['String']['input'];
  position?: InputMaybe<Scalars['Int']['input']>;
  productTypeId: Scalars['ID']['input'];
  required: Scalars['Boolean']['input'];
};

/** Autogenerated return type of UpdatePartCategoryMutation. */
export type UpdatePartCategoryMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partCategory?: Maybe<PartCategory>;
};

export type UpdatePartOptionInput = {
  id: Scalars['ID']['input'];
  inStock?: InputMaybe<Scalars['Boolean']['input']>;
  name: Scalars['String']['input'];
  partCategoryId: Scalars['ID']['input'];
  position?: InputMaybe<Scalars['Int']['input']>;
  price?: InputMaybe<Scalars['Float']['input']>;
  stockQuantity?: InputMaybe<Scalars['Int']['input']>;
};

/** Autogenerated return type of UpdatePartOptionMutation. */
export type UpdatePartOptionMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  partOption?: Maybe<PartOption>;
};

export type UpdatePriceRuleInput = {
  active: Scalars['Boolean']['input'];
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  price: Scalars['Float']['input'];
  productTypeId: Scalars['ID']['input'];
};

/** Autogenerated return type of UpdatePriceRuleMutation. */
export type UpdatePriceRuleMutationPayload = {
  errors?: Maybe<Array<Scalars['String']['output']>>;
  priceRule?: Maybe<PriceRule>;
};

export type UpdateProductDefinitionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  basePrice: Scalars['Float']['input'];
  description: Scalars['String']['input'];
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
  preconfigured?: InputMaybe<Scalars['Boolean']['input']>;
  productSelections?: InputMaybe<Array<ProductSelectionInput>>;
  productTypeId: Scalars['ID']['input'];
};

export type UpdateProductTypeDefinitionInput = {
  active?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id: Scalars['ID']['input'];
  name?: InputMaybe<Scalars['String']['input']>;
};

/** Autogenerated return type of UpdateProductTypesMutation. */
export type UpdateProductTypesMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  productType?: Maybe<ProductTypeDefinition>;
};

/** Autogenerated return type of UpdateProductsMutation. */
export type UpdateProductsMutationPayload = {
  errors: Array<Scalars['String']['output']>;
  product?: Maybe<ProductDefinition>;
};

export type CheckoutCartMutationVariables = Exact<{
  sessionId: Scalars['String']['input'];
}>;


export type CheckoutCartMutation = { checkoutCart: { errors: Array<string> } };

export type CreateCompatibilityRuleMutationVariables = Exact<{
  input: CreateCompatibilityRuleInput;
}>;


export type CreateCompatibilityRuleMutation = { createCompatibilityRule: { errors: Array<string>, compatibilityRule?: { id: string, ruleType: string, requiringOption?: { id: string, name: string } | null, requiredOption?: { id: string, name: string } | null } | null } };

export type UpdateCompatibilityRuleMutationVariables = Exact<{
  input: UpdateCompatibilityRuleInput;
}>;


export type UpdateCompatibilityRuleMutation = { updateCompatibilityRule: { errors: Array<string>, compatibilityRule?: { id: string, ruleType: string, requiringOption?: { id: string, name: string } | null, requiredOption?: { id: string, name: string } | null } | null } };

export type DeleteCompatibilityRuleMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteCompatibilityRuleMutation = { deleteCompatibilityRule: { errors?: Array<string> | null } };

export type CreatePartCategoryMutationVariables = Exact<{
  input: CreatePartCategoryInput;
}>;


export type CreatePartCategoryMutation = { createPartCategory: { partCategory?: { name: string, position?: number | null, active: boolean, required: boolean, productTypeId: string } | null } };

export type UpdatePartCategoryMutationVariables = Exact<{
  input: UpdatePartCategoryInput;
}>;


export type UpdatePartCategoryMutation = { updatePartCategory: { partCategory?: { name: string, position?: number | null, active: boolean, required: boolean, productTypeId: string } | null } };

export type DeletePartCategoryMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePartCategoryMutation = { deletePartCategory: { errors?: Array<string> | null } };

export type CreatePartOptionMutationVariables = Exact<{
  input: CreatePartOptionInput;
}>;


export type CreatePartOptionMutation = { createPartOption: { partOption?: { name: string, price: number, inStock?: boolean | null, stockQuantity?: number | null, partCategoryId: string, position: number } | null } };

export type UpdatePartOptionMutationVariables = Exact<{
  input: UpdatePartOptionInput;
}>;


export type UpdatePartOptionMutation = { updatePartOption: { partOption?: { id: string, name: string, price: number, inStock?: boolean | null, stockQuantity?: number | null, partCategoryId: string, position: number } | null } };

export type DeletePartOptionMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePartOptionMutation = { deletePartOption: { errors?: Array<string> | null } };

export type CreatePriceRuleMutationVariables = Exact<{
  input: CreatePriceRuleInput;
}>;


export type CreatePriceRuleMutation = { createPriceRule: { priceRule?: { id: string, active: boolean, description: string } | null } };

export type UpdatePriceRuleMutationVariables = Exact<{
  input: UpdatePriceRuleInput;
}>;


export type UpdatePriceRuleMutation = { updatePriceRule: { priceRule?: { id: string, active: boolean, description: string } | null } };

export type DeletePriceRuleMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeletePriceRuleMutation = { deletePriceRule: { errors?: Array<string> | null } };

export type DeleteProductTypeMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteProductTypeMutation = { deleteProductType: { errors: Array<string> } };

export type CreateProductTypeMutationVariables = Exact<{
  input: CreateProductTypeDefinitionInput;
}>;


export type CreateProductTypeMutation = { createProductType: { errors: Array<string>, productType: { id: string, name: string, active: boolean, description?: string | null, code: string } } };

export type UpdateProductTypeMutationVariables = Exact<{
  input: UpdateProductTypeDefinitionInput;
}>;


export type UpdateProductTypeMutation = { updateProductType: { errors: Array<string>, productType?: { id: string, name: string, active: boolean, description?: string | null, code: string } | null } };

export type CreateProductMutationVariables = Exact<{
  input: CreateProductDefinitionInput;
}>;


export type CreateProductMutation = { createProduct: { errors: Array<string>, product?: { id: string, name: string, basePrice: number, preconfigured: boolean, description?: string | null, active: boolean, productType: { id: string } } | null } };

export type DeleteProductMutationVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type DeleteProductMutation = { deleteProduct: { errors: Array<string> } };

export type UpdateProductMutationVariables = Exact<{
  input: UpdateProductDefinitionInput;
}>;


export type UpdateProductMutation = { updateProduct: { errors: Array<string>, product?: { id: string, name: string, basePrice: number, description?: string | null, active: boolean, productType: { id: string } } | null } };

export type AddToCartMutationVariables = Exact<{
  productId: Scalars['ID']['input'];
  quantity: Scalars['Int']['input'];
  selectedOptions?: InputMaybe<Scalars['JSON']['input']>;
}>;


export type AddToCartMutation = { addToCart: { errors: Array<string>, cartItem?: { id: string, quantity: number, totalPrice: number, product: { id: string, name: string } } | null } };

export type GetCartQueryVariables = Exact<{
  sessionId: Scalars['String']['input'];
}>;


export type GetCartQuery = { cart: { id?: string | null, totalPrice?: number | null, cartItems?: Array<{ id: string, totalPrice: number, quantity: number, product: { name: string, productType: { name: string } }, partOptions: Array<{ id: string, name: string, price: number, partCategory?: { id: string, name: string, productType: { id: string, name: string } } | null }> }> | null } };

export type OrdersQueryVariables = Exact<{
  sessionId?: InputMaybe<Scalars['String']['input']>;
}>;


export type OrdersQuery = { orders: Array<{ id?: string | null, totalPrice?: number | null, cartItems?: Array<{ id: string, totalPrice: number, quantity: number, product: { name: string, productType: { name: string } }, partOptions: Array<{ id: string, name: string, price: number, partCategory?: { id: string, name: string, productType: { id: string, name: string } } | null }> }> | null }> };

export type GetCompatibilityRulesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCompatibilityRulesQuery = { compatibilityRules: Array<{ id: string, active: boolean, ruleType: string, productType?: { id: string, name: string } | null, requiringOption?: { id: string, name: string } | null, requiredOption?: { id: string, name: string } | null }> };

export type GetCompatibilityRulesForProductTypeQueryVariables = Exact<{
  productTypeId: Scalars['ID']['input'];
}>;


export type GetCompatibilityRulesForProductTypeQuery = { compatibilityRulesForProductType: Array<{ id: string, active: boolean, ruleType: string, productType?: { id: string, name: string } | null, requiringOption?: { id: string, name: string } | null, requiredOption?: { id: string, name: string } | null }> };

export type GetPartCategoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPartCategoriesQuery = { partCategories: Array<{ id: string, name: string, position?: number | null, active: boolean, required: boolean, productType: { id: string, name: string } }> };

export type GetPartCategoryQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetPartCategoryQuery = { partCategory: { id: string, name: string, position?: number | null, active: boolean, productType: { id: string, name: string } } };

export type GetPartCategoriesByProductTypeCodeQueryVariables = Exact<{
  productTypeCode: Scalars['String']['input'];
}>;


export type GetPartCategoriesByProductTypeCodeQuery = { partCategoriesByProductTypeCode: Array<{ id: string, name: string, position?: number | null, active: boolean, required: boolean, productType: { id: string, name: string }, partOptions: Array<{ id: string, name: string, price: number, inStock?: boolean | null }> }> };

export type GetPartCategoriesByProductTypeIdQueryVariables = Exact<{
  productTypeId: Scalars['ID']['input'];
}>;


export type GetPartCategoriesByProductTypeIdQuery = { partCategoriesByProductTypeId: Array<{ id: string, name: string, position?: number | null, active: boolean, required: boolean, productType: { id: string, name: string }, partOptions: Array<{ id: string, name: string, price: number, inStock?: boolean | null }> }> };

export type GetPartOptionsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPartOptionsQuery = { partOptions: Array<{ id: string, name: string, price: number, inStock?: boolean | null, position: number, stockQuantity?: number | null, partCategory?: { id: string, name: string, productType: { id: string, name: string } } | null }> };

export type GetPartOptionQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetPartOptionQuery = { partOption: { id: string, name: string, price: number, inStock?: boolean | null, stockQuantity?: number | null, partCategory?: { id: string, name: string, productType: { id: string, name: string } } | null } };

export type GetPartOptionsByPartCategoryIdQueryVariables = Exact<{
  partCategoryId: Scalars['ID']['input'];
}>;


export type GetPartOptionsByPartCategoryIdQuery = { partOptionsByPartCategoryId: Array<{ id: string, name: string, price: number, inStock?: boolean | null, stockQuantity?: number | null, partCategory?: { id: string, name: string, productType: { id: string, name: string } } | null }> };

export type GetPriceRulesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetPriceRulesQuery = { priceRules: Array<{ id: string, active: boolean, description: string, priceRuleAppliesTo: string, price: number }> };

export type GetPriceRulesForProductTypeQueryVariables = Exact<{
  productTypeId: Scalars['ID']['input'];
}>;


export type GetPriceRulesForProductTypeQuery = { priceRulesForProductType: Array<{ id: string, active: boolean, description: string, price: number, partOptions: Array<{ id: string, name: string, price: number }> }> };

export type GetProductTypesQueryVariables = Exact<{
  active?: InputMaybe<Scalars['Boolean']['input']>;
}>;


export type GetProductTypesQuery = { productTypes: Array<{ id: string, name: string, active: boolean, description?: string | null, code: string }> };

export type GetProductsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetProductsQuery = { products: Array<{ id: string, name: string, basePrice: number, description?: string | null, preconfigured: boolean, active: boolean, productType: { id: string, name: string } }> };

export type GetPreconfiguredProductsQueryVariables = Exact<{
  productType: Scalars['String']['input'];
}>;


export type GetPreconfiguredProductsQuery = { preconfiguredProducts: Array<{ id: string, name: string, basePrice: number, active: boolean, preconfigured: boolean, description?: string | null, productType: { id: string, name: string, code: string } }> };

export type GetProductQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetProductQuery = { product: { id: string, name: string, basePrice: number, active: boolean, preconfigured: boolean, description?: string | null, productType: { id: string, name: string, code: string } } };

export type GetProductByIdQueryVariables = Exact<{
  id: Scalars['ID']['input'];
}>;


export type GetProductByIdQuery = { product: { id: string, name: string, basePrice: number, productType: { id: string, name: string }, productSelections: Array<{ id: string, partOption: { id: string, name: string, partCategory?: { id: string, name: string } | null } }> } };

export type GetProductsByTypeQueryVariables = Exact<{
  productType: Scalars['String']['input'];
}>;


export type GetProductsByTypeQuery = { productsByType: Array<{ id: string, name: string, basePrice: number, productType: { id: string, name: string } }> };


export const CheckoutCartDocument = gql`
    mutation CheckoutCart($sessionId: String!) {
  checkoutCart(sessionId: $sessionId) {
    errors
  }
}
    `;
export type CheckoutCartMutationFn = Apollo.MutationFunction<CheckoutCartMutation, CheckoutCartMutationVariables>;

/**
 * __useCheckoutCartMutation__
 *
 * To run a mutation, you first call `useCheckoutCartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCheckoutCartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [checkoutCartMutation, { data, loading, error }] = useCheckoutCartMutation({
 *   variables: {
 *      sessionId: // value for 'sessionId'
 *   },
 * });
 */
export function useCheckoutCartMutation(baseOptions?: Apollo.MutationHookOptions<CheckoutCartMutation, CheckoutCartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CheckoutCartMutation, CheckoutCartMutationVariables>(CheckoutCartDocument, options);
      }
export type CheckoutCartMutationHookResult = ReturnType<typeof useCheckoutCartMutation>;
export type CheckoutCartMutationResult = Apollo.MutationResult<CheckoutCartMutation>;
export type CheckoutCartMutationOptions = Apollo.BaseMutationOptions<CheckoutCartMutation, CheckoutCartMutationVariables>;
export const CreateCompatibilityRuleDocument = gql`
    mutation CreateCompatibilityRule($input: CreateCompatibilityRuleInput!) {
  createCompatibilityRule(input: $input) {
    compatibilityRule {
      id
      ruleType
      requiringOption {
        id
        name
      }
      requiredOption {
        id
        name
      }
    }
    errors
  }
}
    `;
export type CreateCompatibilityRuleMutationFn = Apollo.MutationFunction<CreateCompatibilityRuleMutation, CreateCompatibilityRuleMutationVariables>;

/**
 * __useCreateCompatibilityRuleMutation__
 *
 * To run a mutation, you first call `useCreateCompatibilityRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateCompatibilityRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createCompatibilityRuleMutation, { data, loading, error }] = useCreateCompatibilityRuleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateCompatibilityRuleMutation(baseOptions?: Apollo.MutationHookOptions<CreateCompatibilityRuleMutation, CreateCompatibilityRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateCompatibilityRuleMutation, CreateCompatibilityRuleMutationVariables>(CreateCompatibilityRuleDocument, options);
      }
export type CreateCompatibilityRuleMutationHookResult = ReturnType<typeof useCreateCompatibilityRuleMutation>;
export type CreateCompatibilityRuleMutationResult = Apollo.MutationResult<CreateCompatibilityRuleMutation>;
export type CreateCompatibilityRuleMutationOptions = Apollo.BaseMutationOptions<CreateCompatibilityRuleMutation, CreateCompatibilityRuleMutationVariables>;
export const UpdateCompatibilityRuleDocument = gql`
    mutation UpdateCompatibilityRule($input: UpdateCompatibilityRuleInput!) {
  updateCompatibilityRule(input: $input) {
    compatibilityRule {
      id
      ruleType
      requiringOption {
        id
        name
      }
      requiredOption {
        id
        name
      }
    }
    errors
  }
}
    `;
export type UpdateCompatibilityRuleMutationFn = Apollo.MutationFunction<UpdateCompatibilityRuleMutation, UpdateCompatibilityRuleMutationVariables>;

/**
 * __useUpdateCompatibilityRuleMutation__
 *
 * To run a mutation, you first call `useUpdateCompatibilityRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCompatibilityRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCompatibilityRuleMutation, { data, loading, error }] = useUpdateCompatibilityRuleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateCompatibilityRuleMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCompatibilityRuleMutation, UpdateCompatibilityRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCompatibilityRuleMutation, UpdateCompatibilityRuleMutationVariables>(UpdateCompatibilityRuleDocument, options);
      }
export type UpdateCompatibilityRuleMutationHookResult = ReturnType<typeof useUpdateCompatibilityRuleMutation>;
export type UpdateCompatibilityRuleMutationResult = Apollo.MutationResult<UpdateCompatibilityRuleMutation>;
export type UpdateCompatibilityRuleMutationOptions = Apollo.BaseMutationOptions<UpdateCompatibilityRuleMutation, UpdateCompatibilityRuleMutationVariables>;
export const DeleteCompatibilityRuleDocument = gql`
    mutation DeleteCompatibilityRule($id: ID!) {
  deleteCompatibilityRule(id: $id) {
    errors
  }
}
    `;
export type DeleteCompatibilityRuleMutationFn = Apollo.MutationFunction<DeleteCompatibilityRuleMutation, DeleteCompatibilityRuleMutationVariables>;

/**
 * __useDeleteCompatibilityRuleMutation__
 *
 * To run a mutation, you first call `useDeleteCompatibilityRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteCompatibilityRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteCompatibilityRuleMutation, { data, loading, error }] = useDeleteCompatibilityRuleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteCompatibilityRuleMutation(baseOptions?: Apollo.MutationHookOptions<DeleteCompatibilityRuleMutation, DeleteCompatibilityRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteCompatibilityRuleMutation, DeleteCompatibilityRuleMutationVariables>(DeleteCompatibilityRuleDocument, options);
      }
export type DeleteCompatibilityRuleMutationHookResult = ReturnType<typeof useDeleteCompatibilityRuleMutation>;
export type DeleteCompatibilityRuleMutationResult = Apollo.MutationResult<DeleteCompatibilityRuleMutation>;
export type DeleteCompatibilityRuleMutationOptions = Apollo.BaseMutationOptions<DeleteCompatibilityRuleMutation, DeleteCompatibilityRuleMutationVariables>;
export const CreatePartCategoryDocument = gql`
    mutation CreatePartCategory($input: CreatePartCategoryInput!) {
  createPartCategory(input: $input) {
    partCategory {
      name
      position
      active
      required
      productTypeId
    }
  }
}
    `;
export type CreatePartCategoryMutationFn = Apollo.MutationFunction<CreatePartCategoryMutation, CreatePartCategoryMutationVariables>;

/**
 * __useCreatePartCategoryMutation__
 *
 * To run a mutation, you first call `useCreatePartCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartCategoryMutation, { data, loading, error }] = useCreatePartCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePartCategoryMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartCategoryMutation, CreatePartCategoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartCategoryMutation, CreatePartCategoryMutationVariables>(CreatePartCategoryDocument, options);
      }
export type CreatePartCategoryMutationHookResult = ReturnType<typeof useCreatePartCategoryMutation>;
export type CreatePartCategoryMutationResult = Apollo.MutationResult<CreatePartCategoryMutation>;
export type CreatePartCategoryMutationOptions = Apollo.BaseMutationOptions<CreatePartCategoryMutation, CreatePartCategoryMutationVariables>;
export const UpdatePartCategoryDocument = gql`
    mutation UpdatePartCategory($input: UpdatePartCategoryInput!) {
  updatePartCategory(input: $input) {
    partCategory {
      name
      position
      active
      required
      productTypeId
    }
  }
}
    `;
export type UpdatePartCategoryMutationFn = Apollo.MutationFunction<UpdatePartCategoryMutation, UpdatePartCategoryMutationVariables>;

/**
 * __useUpdatePartCategoryMutation__
 *
 * To run a mutation, you first call `useUpdatePartCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePartCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePartCategoryMutation, { data, loading, error }] = useUpdatePartCategoryMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePartCategoryMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePartCategoryMutation, UpdatePartCategoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePartCategoryMutation, UpdatePartCategoryMutationVariables>(UpdatePartCategoryDocument, options);
      }
export type UpdatePartCategoryMutationHookResult = ReturnType<typeof useUpdatePartCategoryMutation>;
export type UpdatePartCategoryMutationResult = Apollo.MutationResult<UpdatePartCategoryMutation>;
export type UpdatePartCategoryMutationOptions = Apollo.BaseMutationOptions<UpdatePartCategoryMutation, UpdatePartCategoryMutationVariables>;
export const DeletePartCategoryDocument = gql`
    mutation DeletePartCategory($id: ID!) {
  deletePartCategory(id: $id) {
    errors
  }
}
    `;
export type DeletePartCategoryMutationFn = Apollo.MutationFunction<DeletePartCategoryMutation, DeletePartCategoryMutationVariables>;

/**
 * __useDeletePartCategoryMutation__
 *
 * To run a mutation, you first call `useDeletePartCategoryMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePartCategoryMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePartCategoryMutation, { data, loading, error }] = useDeletePartCategoryMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePartCategoryMutation(baseOptions?: Apollo.MutationHookOptions<DeletePartCategoryMutation, DeletePartCategoryMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePartCategoryMutation, DeletePartCategoryMutationVariables>(DeletePartCategoryDocument, options);
      }
export type DeletePartCategoryMutationHookResult = ReturnType<typeof useDeletePartCategoryMutation>;
export type DeletePartCategoryMutationResult = Apollo.MutationResult<DeletePartCategoryMutation>;
export type DeletePartCategoryMutationOptions = Apollo.BaseMutationOptions<DeletePartCategoryMutation, DeletePartCategoryMutationVariables>;
export const CreatePartOptionDocument = gql`
    mutation CreatePartOption($input: CreatePartOptionInput!) {
  createPartOption(input: $input) {
    partOption {
      name
      price
      inStock
      stockQuantity
      partCategoryId
      position
    }
  }
}
    `;
export type CreatePartOptionMutationFn = Apollo.MutationFunction<CreatePartOptionMutation, CreatePartOptionMutationVariables>;

/**
 * __useCreatePartOptionMutation__
 *
 * To run a mutation, you first call `useCreatePartOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePartOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPartOptionMutation, { data, loading, error }] = useCreatePartOptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePartOptionMutation(baseOptions?: Apollo.MutationHookOptions<CreatePartOptionMutation, CreatePartOptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePartOptionMutation, CreatePartOptionMutationVariables>(CreatePartOptionDocument, options);
      }
export type CreatePartOptionMutationHookResult = ReturnType<typeof useCreatePartOptionMutation>;
export type CreatePartOptionMutationResult = Apollo.MutationResult<CreatePartOptionMutation>;
export type CreatePartOptionMutationOptions = Apollo.BaseMutationOptions<CreatePartOptionMutation, CreatePartOptionMutationVariables>;
export const UpdatePartOptionDocument = gql`
    mutation UpdatePartOption($input: UpdatePartOptionInput!) {
  updatePartOption(input: $input) {
    partOption {
      id
      name
      price
      inStock
      stockQuantity
      partCategoryId
      position
    }
  }
}
    `;
export type UpdatePartOptionMutationFn = Apollo.MutationFunction<UpdatePartOptionMutation, UpdatePartOptionMutationVariables>;

/**
 * __useUpdatePartOptionMutation__
 *
 * To run a mutation, you first call `useUpdatePartOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePartOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePartOptionMutation, { data, loading, error }] = useUpdatePartOptionMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePartOptionMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePartOptionMutation, UpdatePartOptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePartOptionMutation, UpdatePartOptionMutationVariables>(UpdatePartOptionDocument, options);
      }
export type UpdatePartOptionMutationHookResult = ReturnType<typeof useUpdatePartOptionMutation>;
export type UpdatePartOptionMutationResult = Apollo.MutationResult<UpdatePartOptionMutation>;
export type UpdatePartOptionMutationOptions = Apollo.BaseMutationOptions<UpdatePartOptionMutation, UpdatePartOptionMutationVariables>;
export const DeletePartOptionDocument = gql`
    mutation DeletePartOption($id: ID!) {
  deletePartOption(id: $id) {
    errors
  }
}
    `;
export type DeletePartOptionMutationFn = Apollo.MutationFunction<DeletePartOptionMutation, DeletePartOptionMutationVariables>;

/**
 * __useDeletePartOptionMutation__
 *
 * To run a mutation, you first call `useDeletePartOptionMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePartOptionMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePartOptionMutation, { data, loading, error }] = useDeletePartOptionMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePartOptionMutation(baseOptions?: Apollo.MutationHookOptions<DeletePartOptionMutation, DeletePartOptionMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePartOptionMutation, DeletePartOptionMutationVariables>(DeletePartOptionDocument, options);
      }
export type DeletePartOptionMutationHookResult = ReturnType<typeof useDeletePartOptionMutation>;
export type DeletePartOptionMutationResult = Apollo.MutationResult<DeletePartOptionMutation>;
export type DeletePartOptionMutationOptions = Apollo.BaseMutationOptions<DeletePartOptionMutation, DeletePartOptionMutationVariables>;
export const CreatePriceRuleDocument = gql`
    mutation CreatePriceRule($input: CreatePriceRuleInput!) {
  createPriceRule(input: $input) {
    priceRule {
      id
      active
      description
    }
  }
}
    `;
export type CreatePriceRuleMutationFn = Apollo.MutationFunction<CreatePriceRuleMutation, CreatePriceRuleMutationVariables>;

/**
 * __useCreatePriceRuleMutation__
 *
 * To run a mutation, you first call `useCreatePriceRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreatePriceRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createPriceRuleMutation, { data, loading, error }] = useCreatePriceRuleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreatePriceRuleMutation(baseOptions?: Apollo.MutationHookOptions<CreatePriceRuleMutation, CreatePriceRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreatePriceRuleMutation, CreatePriceRuleMutationVariables>(CreatePriceRuleDocument, options);
      }
export type CreatePriceRuleMutationHookResult = ReturnType<typeof useCreatePriceRuleMutation>;
export type CreatePriceRuleMutationResult = Apollo.MutationResult<CreatePriceRuleMutation>;
export type CreatePriceRuleMutationOptions = Apollo.BaseMutationOptions<CreatePriceRuleMutation, CreatePriceRuleMutationVariables>;
export const UpdatePriceRuleDocument = gql`
    mutation UpdatePriceRule($input: UpdatePriceRuleInput!) {
  updatePriceRule(input: $input) {
    priceRule {
      id
      active
      description
    }
  }
}
    `;
export type UpdatePriceRuleMutationFn = Apollo.MutationFunction<UpdatePriceRuleMutation, UpdatePriceRuleMutationVariables>;

/**
 * __useUpdatePriceRuleMutation__
 *
 * To run a mutation, you first call `useUpdatePriceRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdatePriceRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updatePriceRuleMutation, { data, loading, error }] = useUpdatePriceRuleMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdatePriceRuleMutation(baseOptions?: Apollo.MutationHookOptions<UpdatePriceRuleMutation, UpdatePriceRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdatePriceRuleMutation, UpdatePriceRuleMutationVariables>(UpdatePriceRuleDocument, options);
      }
export type UpdatePriceRuleMutationHookResult = ReturnType<typeof useUpdatePriceRuleMutation>;
export type UpdatePriceRuleMutationResult = Apollo.MutationResult<UpdatePriceRuleMutation>;
export type UpdatePriceRuleMutationOptions = Apollo.BaseMutationOptions<UpdatePriceRuleMutation, UpdatePriceRuleMutationVariables>;
export const DeletePriceRuleDocument = gql`
    mutation DeletePriceRule($id: ID!) {
  deletePriceRule(id: $id) {
    errors
  }
}
    `;
export type DeletePriceRuleMutationFn = Apollo.MutationFunction<DeletePriceRuleMutation, DeletePriceRuleMutationVariables>;

/**
 * __useDeletePriceRuleMutation__
 *
 * To run a mutation, you first call `useDeletePriceRuleMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeletePriceRuleMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deletePriceRuleMutation, { data, loading, error }] = useDeletePriceRuleMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeletePriceRuleMutation(baseOptions?: Apollo.MutationHookOptions<DeletePriceRuleMutation, DeletePriceRuleMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeletePriceRuleMutation, DeletePriceRuleMutationVariables>(DeletePriceRuleDocument, options);
      }
export type DeletePriceRuleMutationHookResult = ReturnType<typeof useDeletePriceRuleMutation>;
export type DeletePriceRuleMutationResult = Apollo.MutationResult<DeletePriceRuleMutation>;
export type DeletePriceRuleMutationOptions = Apollo.BaseMutationOptions<DeletePriceRuleMutation, DeletePriceRuleMutationVariables>;
export const DeleteProductTypeDocument = gql`
    mutation DeleteProductType($id: ID!) {
  deleteProductType(id: $id) {
    errors
  }
}
    `;
export type DeleteProductTypeMutationFn = Apollo.MutationFunction<DeleteProductTypeMutation, DeleteProductTypeMutationVariables>;

/**
 * __useDeleteProductTypeMutation__
 *
 * To run a mutation, you first call `useDeleteProductTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProductTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProductTypeMutation, { data, loading, error }] = useDeleteProductTypeMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteProductTypeMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProductTypeMutation, DeleteProductTypeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProductTypeMutation, DeleteProductTypeMutationVariables>(DeleteProductTypeDocument, options);
      }
export type DeleteProductTypeMutationHookResult = ReturnType<typeof useDeleteProductTypeMutation>;
export type DeleteProductTypeMutationResult = Apollo.MutationResult<DeleteProductTypeMutation>;
export type DeleteProductTypeMutationOptions = Apollo.BaseMutationOptions<DeleteProductTypeMutation, DeleteProductTypeMutationVariables>;
export const CreateProductTypeDocument = gql`
    mutation CreateProductType($input: CreateProductTypeDefinitionInput!) {
  createProductType(input: $input) {
    productType {
      id
      name
      active
      description
      code
    }
    errors
  }
}
    `;
export type CreateProductTypeMutationFn = Apollo.MutationFunction<CreateProductTypeMutation, CreateProductTypeMutationVariables>;

/**
 * __useCreateProductTypeMutation__
 *
 * To run a mutation, you first call `useCreateProductTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductTypeMutation, { data, loading, error }] = useCreateProductTypeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateProductTypeMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductTypeMutation, CreateProductTypeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductTypeMutation, CreateProductTypeMutationVariables>(CreateProductTypeDocument, options);
      }
export type CreateProductTypeMutationHookResult = ReturnType<typeof useCreateProductTypeMutation>;
export type CreateProductTypeMutationResult = Apollo.MutationResult<CreateProductTypeMutation>;
export type CreateProductTypeMutationOptions = Apollo.BaseMutationOptions<CreateProductTypeMutation, CreateProductTypeMutationVariables>;
export const UpdateProductTypeDocument = gql`
    mutation UpdateProductType($input: UpdateProductTypeDefinitionInput!) {
  updateProductType(input: $input) {
    productType {
      id
      name
      active
      description
      code
    }
    errors
  }
}
    `;
export type UpdateProductTypeMutationFn = Apollo.MutationFunction<UpdateProductTypeMutation, UpdateProductTypeMutationVariables>;

/**
 * __useUpdateProductTypeMutation__
 *
 * To run a mutation, you first call `useUpdateProductTypeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductTypeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductTypeMutation, { data, loading, error }] = useUpdateProductTypeMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateProductTypeMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductTypeMutation, UpdateProductTypeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductTypeMutation, UpdateProductTypeMutationVariables>(UpdateProductTypeDocument, options);
      }
export type UpdateProductTypeMutationHookResult = ReturnType<typeof useUpdateProductTypeMutation>;
export type UpdateProductTypeMutationResult = Apollo.MutationResult<UpdateProductTypeMutation>;
export type UpdateProductTypeMutationOptions = Apollo.BaseMutationOptions<UpdateProductTypeMutation, UpdateProductTypeMutationVariables>;
export const CreateProductDocument = gql`
    mutation CreateProduct($input: CreateProductDefinitionInput!) {
  createProduct(input: $input) {
    product {
      id
      name
      basePrice
      preconfigured
      productType {
        id
      }
      description
      active
    }
    errors
  }
}
    `;
export type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;

/**
 * __useCreateProductMutation__
 *
 * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);
      }
export type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;
export type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;
export type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;
export const DeleteProductDocument = gql`
    mutation DeleteProduct($id: ID!) {
  deleteProduct(id: $id) {
    errors
  }
}
    `;
export type DeleteProductMutationFn = Apollo.MutationFunction<DeleteProductMutation, DeleteProductMutationVariables>;

/**
 * __useDeleteProductMutation__
 *
 * To run a mutation, you first call `useDeleteProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProductMutation, { data, loading, error }] = useDeleteProductMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteProductMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProductMutation, DeleteProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProductMutation, DeleteProductMutationVariables>(DeleteProductDocument, options);
      }
export type DeleteProductMutationHookResult = ReturnType<typeof useDeleteProductMutation>;
export type DeleteProductMutationResult = Apollo.MutationResult<DeleteProductMutation>;
export type DeleteProductMutationOptions = Apollo.BaseMutationOptions<DeleteProductMutation, DeleteProductMutationVariables>;
export const UpdateProductDocument = gql`
    mutation UpdateProduct($input: UpdateProductDefinitionInput!) {
  updateProduct(input: $input) {
    product {
      id
      name
      basePrice
      productType {
        id
      }
      description
      active
    }
    errors
  }
}
    `;
export type UpdateProductMutationFn = Apollo.MutationFunction<UpdateProductMutation, UpdateProductMutationVariables>;

/**
 * __useUpdateProductMutation__
 *
 * To run a mutation, you first call `useUpdateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMutation, { data, loading, error }] = useUpdateProductMutation({
 *   variables: {
 *      input: // value for 'input'
 *   },
 * });
 */
export function useUpdateProductMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMutation, UpdateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMutation, UpdateProductMutationVariables>(UpdateProductDocument, options);
      }
export type UpdateProductMutationHookResult = ReturnType<typeof useUpdateProductMutation>;
export type UpdateProductMutationResult = Apollo.MutationResult<UpdateProductMutation>;
export type UpdateProductMutationOptions = Apollo.BaseMutationOptions<UpdateProductMutation, UpdateProductMutationVariables>;
export const AddToCartDocument = gql`
    mutation AddToCart($productId: ID!, $quantity: Int!, $selectedOptions: JSON) {
  addToCart(
    productId: $productId
    quantity: $quantity
    selectedOptions: $selectedOptions
  ) {
    cartItem {
      id
      product {
        id
        name
      }
      quantity
      totalPrice
    }
    errors
  }
}
    `;
export type AddToCartMutationFn = Apollo.MutationFunction<AddToCartMutation, AddToCartMutationVariables>;

/**
 * __useAddToCartMutation__
 *
 * To run a mutation, you first call `useAddToCartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddToCartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addToCartMutation, { data, loading, error }] = useAddToCartMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *      quantity: // value for 'quantity'
 *      selectedOptions: // value for 'selectedOptions'
 *   },
 * });
 */
export function useAddToCartMutation(baseOptions?: Apollo.MutationHookOptions<AddToCartMutation, AddToCartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddToCartMutation, AddToCartMutationVariables>(AddToCartDocument, options);
      }
export type AddToCartMutationHookResult = ReturnType<typeof useAddToCartMutation>;
export type AddToCartMutationResult = Apollo.MutationResult<AddToCartMutation>;
export type AddToCartMutationOptions = Apollo.BaseMutationOptions<AddToCartMutation, AddToCartMutationVariables>;
export const GetCartDocument = gql`
    query GetCart($sessionId: String!) {
  cart(sessionId: $sessionId) {
    id
    totalPrice
    cartItems {
      id
      totalPrice
      product {
        name
        productType {
          name
        }
      }
      partOptions {
        id
        name
        price
        partCategory {
          id
          name
          productType {
            id
            name
          }
        }
      }
      quantity
    }
  }
}
    `;

/**
 * __useGetCartQuery__
 *
 * To run a query within a React component, call `useGetCartQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCartQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCartQuery({
 *   variables: {
 *      sessionId: // value for 'sessionId'
 *   },
 * });
 */
export function useGetCartQuery(baseOptions: Apollo.QueryHookOptions<GetCartQuery, GetCartQueryVariables> & ({ variables: GetCartQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCartQuery, GetCartQueryVariables>(GetCartDocument, options);
      }
export function useGetCartLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCartQuery, GetCartQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCartQuery, GetCartQueryVariables>(GetCartDocument, options);
        }
export function useGetCartSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCartQuery, GetCartQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCartQuery, GetCartQueryVariables>(GetCartDocument, options);
        }
export type GetCartQueryHookResult = ReturnType<typeof useGetCartQuery>;
export type GetCartLazyQueryHookResult = ReturnType<typeof useGetCartLazyQuery>;
export type GetCartSuspenseQueryHookResult = ReturnType<typeof useGetCartSuspenseQuery>;
export type GetCartQueryResult = Apollo.QueryResult<GetCartQuery, GetCartQueryVariables>;
export const OrdersDocument = gql`
    query Orders($sessionId: String) {
  orders(sessionId: $sessionId) {
    id
    totalPrice
    cartItems {
      id
      totalPrice
      product {
        name
        productType {
          name
        }
      }
      partOptions {
        id
        name
        price
        partCategory {
          id
          name
          productType {
            id
            name
          }
        }
      }
      quantity
    }
  }
}
    `;

/**
 * __useOrdersQuery__
 *
 * To run a query within a React component, call `useOrdersQuery` and pass it any options that fit your needs.
 * When your component renders, `useOrdersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useOrdersQuery({
 *   variables: {
 *      sessionId: // value for 'sessionId'
 *   },
 * });
 */
export function useOrdersQuery(baseOptions?: Apollo.QueryHookOptions<OrdersQuery, OrdersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
      }
export function useOrdersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<OrdersQuery, OrdersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
        }
export function useOrdersSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<OrdersQuery, OrdersQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<OrdersQuery, OrdersQueryVariables>(OrdersDocument, options);
        }
export type OrdersQueryHookResult = ReturnType<typeof useOrdersQuery>;
export type OrdersLazyQueryHookResult = ReturnType<typeof useOrdersLazyQuery>;
export type OrdersSuspenseQueryHookResult = ReturnType<typeof useOrdersSuspenseQuery>;
export type OrdersQueryResult = Apollo.QueryResult<OrdersQuery, OrdersQueryVariables>;
export const GetCompatibilityRulesDocument = gql`
    query GetCompatibilityRules {
  compatibilityRules {
    id
    active
    productType {
      id
      name
    }
    ruleType
    requiringOption {
      id
      name
    }
    requiredOption {
      id
      name
    }
  }
}
    `;

/**
 * __useGetCompatibilityRulesQuery__
 *
 * To run a query within a React component, call `useGetCompatibilityRulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCompatibilityRulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCompatibilityRulesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCompatibilityRulesQuery(baseOptions?: Apollo.QueryHookOptions<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>(GetCompatibilityRulesDocument, options);
      }
export function useGetCompatibilityRulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>(GetCompatibilityRulesDocument, options);
        }
export function useGetCompatibilityRulesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>(GetCompatibilityRulesDocument, options);
        }
export type GetCompatibilityRulesQueryHookResult = ReturnType<typeof useGetCompatibilityRulesQuery>;
export type GetCompatibilityRulesLazyQueryHookResult = ReturnType<typeof useGetCompatibilityRulesLazyQuery>;
export type GetCompatibilityRulesSuspenseQueryHookResult = ReturnType<typeof useGetCompatibilityRulesSuspenseQuery>;
export type GetCompatibilityRulesQueryResult = Apollo.QueryResult<GetCompatibilityRulesQuery, GetCompatibilityRulesQueryVariables>;
export const GetCompatibilityRulesForProductTypeDocument = gql`
    query GetCompatibilityRulesForProductType($productTypeId: ID!) {
  compatibilityRulesForProductType(productTypeId: $productTypeId) {
    id
    active
    productType {
      id
      name
    }
    ruleType
    requiringOption {
      id
      name
    }
    requiredOption {
      id
      name
    }
  }
}
    `;

/**
 * __useGetCompatibilityRulesForProductTypeQuery__
 *
 * To run a query within a React component, call `useGetCompatibilityRulesForProductTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCompatibilityRulesForProductTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCompatibilityRulesForProductTypeQuery({
 *   variables: {
 *      productTypeId: // value for 'productTypeId'
 *   },
 * });
 */
export function useGetCompatibilityRulesForProductTypeQuery(baseOptions: Apollo.QueryHookOptions<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables> & ({ variables: GetCompatibilityRulesForProductTypeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>(GetCompatibilityRulesForProductTypeDocument, options);
      }
export function useGetCompatibilityRulesForProductTypeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>(GetCompatibilityRulesForProductTypeDocument, options);
        }
export function useGetCompatibilityRulesForProductTypeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>(GetCompatibilityRulesForProductTypeDocument, options);
        }
export type GetCompatibilityRulesForProductTypeQueryHookResult = ReturnType<typeof useGetCompatibilityRulesForProductTypeQuery>;
export type GetCompatibilityRulesForProductTypeLazyQueryHookResult = ReturnType<typeof useGetCompatibilityRulesForProductTypeLazyQuery>;
export type GetCompatibilityRulesForProductTypeSuspenseQueryHookResult = ReturnType<typeof useGetCompatibilityRulesForProductTypeSuspenseQuery>;
export type GetCompatibilityRulesForProductTypeQueryResult = Apollo.QueryResult<GetCompatibilityRulesForProductTypeQuery, GetCompatibilityRulesForProductTypeQueryVariables>;
export const GetPartCategoriesDocument = gql`
    query GetPartCategories {
  partCategories {
    id
    name
    position
    active
    required
    productType {
      id
      name
    }
  }
}
    `;

/**
 * __useGetPartCategoriesQuery__
 *
 * To run a query within a React component, call `useGetPartCategoriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartCategoriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartCategoriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPartCategoriesQuery(baseOptions?: Apollo.QueryHookOptions<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>(GetPartCategoriesDocument, options);
      }
export function useGetPartCategoriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>(GetPartCategoriesDocument, options);
        }
export function useGetPartCategoriesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>(GetPartCategoriesDocument, options);
        }
export type GetPartCategoriesQueryHookResult = ReturnType<typeof useGetPartCategoriesQuery>;
export type GetPartCategoriesLazyQueryHookResult = ReturnType<typeof useGetPartCategoriesLazyQuery>;
export type GetPartCategoriesSuspenseQueryHookResult = ReturnType<typeof useGetPartCategoriesSuspenseQuery>;
export type GetPartCategoriesQueryResult = Apollo.QueryResult<GetPartCategoriesQuery, GetPartCategoriesQueryVariables>;
export const GetPartCategoryDocument = gql`
    query GetPartCategory($id: ID!) {
  partCategory(id: $id) {
    id
    name
    position
    active
    productType {
      id
      name
    }
  }
}
    `;

/**
 * __useGetPartCategoryQuery__
 *
 * To run a query within a React component, call `useGetPartCategoryQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartCategoryQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartCategoryQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPartCategoryQuery(baseOptions: Apollo.QueryHookOptions<GetPartCategoryQuery, GetPartCategoryQueryVariables> & ({ variables: GetPartCategoryQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartCategoryQuery, GetPartCategoryQueryVariables>(GetPartCategoryDocument, options);
      }
export function useGetPartCategoryLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartCategoryQuery, GetPartCategoryQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartCategoryQuery, GetPartCategoryQueryVariables>(GetPartCategoryDocument, options);
        }
export function useGetPartCategorySuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartCategoryQuery, GetPartCategoryQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartCategoryQuery, GetPartCategoryQueryVariables>(GetPartCategoryDocument, options);
        }
export type GetPartCategoryQueryHookResult = ReturnType<typeof useGetPartCategoryQuery>;
export type GetPartCategoryLazyQueryHookResult = ReturnType<typeof useGetPartCategoryLazyQuery>;
export type GetPartCategorySuspenseQueryHookResult = ReturnType<typeof useGetPartCategorySuspenseQuery>;
export type GetPartCategoryQueryResult = Apollo.QueryResult<GetPartCategoryQuery, GetPartCategoryQueryVariables>;
export const GetPartCategoriesByProductTypeCodeDocument = gql`
    query GetPartCategoriesByProductTypeCode($productTypeCode: String!) {
  partCategoriesByProductTypeCode(productTypeCode: $productTypeCode) {
    id
    name
    position
    active
    required
    productType {
      id
      name
    }
    partOptions {
      id
      name
      price
      inStock
    }
  }
}
    `;

/**
 * __useGetPartCategoriesByProductTypeCodeQuery__
 *
 * To run a query within a React component, call `useGetPartCategoriesByProductTypeCodeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartCategoriesByProductTypeCodeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartCategoriesByProductTypeCodeQuery({
 *   variables: {
 *      productTypeCode: // value for 'productTypeCode'
 *   },
 * });
 */
export function useGetPartCategoriesByProductTypeCodeQuery(baseOptions: Apollo.QueryHookOptions<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables> & ({ variables: GetPartCategoriesByProductTypeCodeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>(GetPartCategoriesByProductTypeCodeDocument, options);
      }
export function useGetPartCategoriesByProductTypeCodeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>(GetPartCategoriesByProductTypeCodeDocument, options);
        }
export function useGetPartCategoriesByProductTypeCodeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>(GetPartCategoriesByProductTypeCodeDocument, options);
        }
export type GetPartCategoriesByProductTypeCodeQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeCodeQuery>;
export type GetPartCategoriesByProductTypeCodeLazyQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeCodeLazyQuery>;
export type GetPartCategoriesByProductTypeCodeSuspenseQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeCodeSuspenseQuery>;
export type GetPartCategoriesByProductTypeCodeQueryResult = Apollo.QueryResult<GetPartCategoriesByProductTypeCodeQuery, GetPartCategoriesByProductTypeCodeQueryVariables>;
export const GetPartCategoriesByProductTypeIdDocument = gql`
    query GetPartCategoriesByProductTypeId($productTypeId: ID!) {
  partCategoriesByProductTypeId(productTypeId: $productTypeId) {
    id
    name
    position
    active
    required
    productType {
      id
      name
    }
    partOptions {
      id
      name
      price
      inStock
    }
  }
}
    `;

/**
 * __useGetPartCategoriesByProductTypeIdQuery__
 *
 * To run a query within a React component, call `useGetPartCategoriesByProductTypeIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartCategoriesByProductTypeIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartCategoriesByProductTypeIdQuery({
 *   variables: {
 *      productTypeId: // value for 'productTypeId'
 *   },
 * });
 */
export function useGetPartCategoriesByProductTypeIdQuery(baseOptions: Apollo.QueryHookOptions<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables> & ({ variables: GetPartCategoriesByProductTypeIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>(GetPartCategoriesByProductTypeIdDocument, options);
      }
export function useGetPartCategoriesByProductTypeIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>(GetPartCategoriesByProductTypeIdDocument, options);
        }
export function useGetPartCategoriesByProductTypeIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>(GetPartCategoriesByProductTypeIdDocument, options);
        }
export type GetPartCategoriesByProductTypeIdQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeIdQuery>;
export type GetPartCategoriesByProductTypeIdLazyQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeIdLazyQuery>;
export type GetPartCategoriesByProductTypeIdSuspenseQueryHookResult = ReturnType<typeof useGetPartCategoriesByProductTypeIdSuspenseQuery>;
export type GetPartCategoriesByProductTypeIdQueryResult = Apollo.QueryResult<GetPartCategoriesByProductTypeIdQuery, GetPartCategoriesByProductTypeIdQueryVariables>;
export const GetPartOptionsDocument = gql`
    query GetPartOptions {
  partOptions {
    id
    name
    price
    inStock
    position
    stockQuantity
    partCategory {
      id
      name
      productType {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useGetPartOptionsQuery__
 *
 * To run a query within a React component, call `useGetPartOptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartOptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartOptionsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPartOptionsQuery(baseOptions?: Apollo.QueryHookOptions<GetPartOptionsQuery, GetPartOptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartOptionsQuery, GetPartOptionsQueryVariables>(GetPartOptionsDocument, options);
      }
export function useGetPartOptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartOptionsQuery, GetPartOptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartOptionsQuery, GetPartOptionsQueryVariables>(GetPartOptionsDocument, options);
        }
export function useGetPartOptionsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartOptionsQuery, GetPartOptionsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartOptionsQuery, GetPartOptionsQueryVariables>(GetPartOptionsDocument, options);
        }
export type GetPartOptionsQueryHookResult = ReturnType<typeof useGetPartOptionsQuery>;
export type GetPartOptionsLazyQueryHookResult = ReturnType<typeof useGetPartOptionsLazyQuery>;
export type GetPartOptionsSuspenseQueryHookResult = ReturnType<typeof useGetPartOptionsSuspenseQuery>;
export type GetPartOptionsQueryResult = Apollo.QueryResult<GetPartOptionsQuery, GetPartOptionsQueryVariables>;
export const GetPartOptionDocument = gql`
    query GetPartOption($id: ID!) {
  partOption(id: $id) {
    id
    name
    price
    inStock
    stockQuantity
    partCategory {
      id
      name
      productType {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useGetPartOptionQuery__
 *
 * To run a query within a React component, call `useGetPartOptionQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartOptionQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartOptionQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetPartOptionQuery(baseOptions: Apollo.QueryHookOptions<GetPartOptionQuery, GetPartOptionQueryVariables> & ({ variables: GetPartOptionQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartOptionQuery, GetPartOptionQueryVariables>(GetPartOptionDocument, options);
      }
export function useGetPartOptionLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartOptionQuery, GetPartOptionQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartOptionQuery, GetPartOptionQueryVariables>(GetPartOptionDocument, options);
        }
export function useGetPartOptionSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartOptionQuery, GetPartOptionQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartOptionQuery, GetPartOptionQueryVariables>(GetPartOptionDocument, options);
        }
export type GetPartOptionQueryHookResult = ReturnType<typeof useGetPartOptionQuery>;
export type GetPartOptionLazyQueryHookResult = ReturnType<typeof useGetPartOptionLazyQuery>;
export type GetPartOptionSuspenseQueryHookResult = ReturnType<typeof useGetPartOptionSuspenseQuery>;
export type GetPartOptionQueryResult = Apollo.QueryResult<GetPartOptionQuery, GetPartOptionQueryVariables>;
export const GetPartOptionsByPartCategoryIdDocument = gql`
    query GetPartOptionsByPartCategoryId($partCategoryId: ID!) {
  partOptionsByPartCategoryId(partCategoryId: $partCategoryId) {
    id
    name
    price
    inStock
    stockQuantity
    partCategory {
      id
      name
      productType {
        id
        name
      }
    }
  }
}
    `;

/**
 * __useGetPartOptionsByPartCategoryIdQuery__
 *
 * To run a query within a React component, call `useGetPartOptionsByPartCategoryIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPartOptionsByPartCategoryIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPartOptionsByPartCategoryIdQuery({
 *   variables: {
 *      partCategoryId: // value for 'partCategoryId'
 *   },
 * });
 */
export function useGetPartOptionsByPartCategoryIdQuery(baseOptions: Apollo.QueryHookOptions<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables> & ({ variables: GetPartOptionsByPartCategoryIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>(GetPartOptionsByPartCategoryIdDocument, options);
      }
export function useGetPartOptionsByPartCategoryIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>(GetPartOptionsByPartCategoryIdDocument, options);
        }
export function useGetPartOptionsByPartCategoryIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>(GetPartOptionsByPartCategoryIdDocument, options);
        }
export type GetPartOptionsByPartCategoryIdQueryHookResult = ReturnType<typeof useGetPartOptionsByPartCategoryIdQuery>;
export type GetPartOptionsByPartCategoryIdLazyQueryHookResult = ReturnType<typeof useGetPartOptionsByPartCategoryIdLazyQuery>;
export type GetPartOptionsByPartCategoryIdSuspenseQueryHookResult = ReturnType<typeof useGetPartOptionsByPartCategoryIdSuspenseQuery>;
export type GetPartOptionsByPartCategoryIdQueryResult = Apollo.QueryResult<GetPartOptionsByPartCategoryIdQuery, GetPartOptionsByPartCategoryIdQueryVariables>;
export const GetPriceRulesDocument = gql`
    query GetPriceRules {
  priceRules {
    id
    active
    description
    priceRuleAppliesTo
    price
  }
}
    `;

/**
 * __useGetPriceRulesQuery__
 *
 * To run a query within a React component, call `useGetPriceRulesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPriceRulesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPriceRulesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetPriceRulesQuery(baseOptions?: Apollo.QueryHookOptions<GetPriceRulesQuery, GetPriceRulesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPriceRulesQuery, GetPriceRulesQueryVariables>(GetPriceRulesDocument, options);
      }
export function useGetPriceRulesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPriceRulesQuery, GetPriceRulesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPriceRulesQuery, GetPriceRulesQueryVariables>(GetPriceRulesDocument, options);
        }
export function useGetPriceRulesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPriceRulesQuery, GetPriceRulesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPriceRulesQuery, GetPriceRulesQueryVariables>(GetPriceRulesDocument, options);
        }
export type GetPriceRulesQueryHookResult = ReturnType<typeof useGetPriceRulesQuery>;
export type GetPriceRulesLazyQueryHookResult = ReturnType<typeof useGetPriceRulesLazyQuery>;
export type GetPriceRulesSuspenseQueryHookResult = ReturnType<typeof useGetPriceRulesSuspenseQuery>;
export type GetPriceRulesQueryResult = Apollo.QueryResult<GetPriceRulesQuery, GetPriceRulesQueryVariables>;
export const GetPriceRulesForProductTypeDocument = gql`
    query GetPriceRulesForProductType($productTypeId: ID!) {
  priceRulesForProductType(productTypeId: $productTypeId) {
    id
    active
    description
    partOptions {
      id
      name
      price
    }
    price
  }
}
    `;

/**
 * __useGetPriceRulesForProductTypeQuery__
 *
 * To run a query within a React component, call `useGetPriceRulesForProductTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPriceRulesForProductTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPriceRulesForProductTypeQuery({
 *   variables: {
 *      productTypeId: // value for 'productTypeId'
 *   },
 * });
 */
export function useGetPriceRulesForProductTypeQuery(baseOptions: Apollo.QueryHookOptions<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables> & ({ variables: GetPriceRulesForProductTypeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>(GetPriceRulesForProductTypeDocument, options);
      }
export function useGetPriceRulesForProductTypeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>(GetPriceRulesForProductTypeDocument, options);
        }
export function useGetPriceRulesForProductTypeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>(GetPriceRulesForProductTypeDocument, options);
        }
export type GetPriceRulesForProductTypeQueryHookResult = ReturnType<typeof useGetPriceRulesForProductTypeQuery>;
export type GetPriceRulesForProductTypeLazyQueryHookResult = ReturnType<typeof useGetPriceRulesForProductTypeLazyQuery>;
export type GetPriceRulesForProductTypeSuspenseQueryHookResult = ReturnType<typeof useGetPriceRulesForProductTypeSuspenseQuery>;
export type GetPriceRulesForProductTypeQueryResult = Apollo.QueryResult<GetPriceRulesForProductTypeQuery, GetPriceRulesForProductTypeQueryVariables>;
export const GetProductTypesDocument = gql`
    query GetProductTypes($active: Boolean) {
  productTypes(active: $active) {
    id
    name
    active
    description
    code
  }
}
    `;

/**
 * __useGetProductTypesQuery__
 *
 * To run a query within a React component, call `useGetProductTypesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductTypesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductTypesQuery({
 *   variables: {
 *      active: // value for 'active'
 *   },
 * });
 */
export function useGetProductTypesQuery(baseOptions?: Apollo.QueryHookOptions<GetProductTypesQuery, GetProductTypesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductTypesQuery, GetProductTypesQueryVariables>(GetProductTypesDocument, options);
      }
export function useGetProductTypesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductTypesQuery, GetProductTypesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductTypesQuery, GetProductTypesQueryVariables>(GetProductTypesDocument, options);
        }
export function useGetProductTypesSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProductTypesQuery, GetProductTypesQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProductTypesQuery, GetProductTypesQueryVariables>(GetProductTypesDocument, options);
        }
export type GetProductTypesQueryHookResult = ReturnType<typeof useGetProductTypesQuery>;
export type GetProductTypesLazyQueryHookResult = ReturnType<typeof useGetProductTypesLazyQuery>;
export type GetProductTypesSuspenseQueryHookResult = ReturnType<typeof useGetProductTypesSuspenseQuery>;
export type GetProductTypesQueryResult = Apollo.QueryResult<GetProductTypesQuery, GetProductTypesQueryVariables>;
export const GetProductsDocument = gql`
    query GetProducts {
  products {
    id
    name
    basePrice
    description
    preconfigured
    active
    productType {
      id
      name
    }
  }
}
    `;

/**
 * __useGetProductsQuery__
 *
 * To run a query within a React component, call `useGetProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetProductsQuery(baseOptions?: Apollo.QueryHookOptions<GetProductsQuery, GetProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductsQuery, GetProductsQueryVariables>(GetProductsDocument, options);
      }
export function useGetProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductsQuery, GetProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductsQuery, GetProductsQueryVariables>(GetProductsDocument, options);
        }
export function useGetProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProductsQuery, GetProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProductsQuery, GetProductsQueryVariables>(GetProductsDocument, options);
        }
export type GetProductsQueryHookResult = ReturnType<typeof useGetProductsQuery>;
export type GetProductsLazyQueryHookResult = ReturnType<typeof useGetProductsLazyQuery>;
export type GetProductsSuspenseQueryHookResult = ReturnType<typeof useGetProductsSuspenseQuery>;
export type GetProductsQueryResult = Apollo.QueryResult<GetProductsQuery, GetProductsQueryVariables>;
export const GetPreconfiguredProductsDocument = gql`
    query GetPreconfiguredProducts($productType: String!) {
  preconfiguredProducts(productType: $productType) {
    id
    name
    productType {
      id
      name
      code
    }
    basePrice
    active
    preconfigured
    description
  }
}
    `;

/**
 * __useGetPreconfiguredProductsQuery__
 *
 * To run a query within a React component, call `useGetPreconfiguredProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetPreconfiguredProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetPreconfiguredProductsQuery({
 *   variables: {
 *      productType: // value for 'productType'
 *   },
 * });
 */
export function useGetPreconfiguredProductsQuery(baseOptions: Apollo.QueryHookOptions<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables> & ({ variables: GetPreconfiguredProductsQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>(GetPreconfiguredProductsDocument, options);
      }
export function useGetPreconfiguredProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>(GetPreconfiguredProductsDocument, options);
        }
export function useGetPreconfiguredProductsSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>(GetPreconfiguredProductsDocument, options);
        }
export type GetPreconfiguredProductsQueryHookResult = ReturnType<typeof useGetPreconfiguredProductsQuery>;
export type GetPreconfiguredProductsLazyQueryHookResult = ReturnType<typeof useGetPreconfiguredProductsLazyQuery>;
export type GetPreconfiguredProductsSuspenseQueryHookResult = ReturnType<typeof useGetPreconfiguredProductsSuspenseQuery>;
export type GetPreconfiguredProductsQueryResult = Apollo.QueryResult<GetPreconfiguredProductsQuery, GetPreconfiguredProductsQueryVariables>;
export const GetProductDocument = gql`
    query GetProduct($id: ID!) {
  product(id: $id) {
    id
    name
    productType {
      id
      name
      code
    }
    basePrice
    active
    preconfigured
    description
  }
}
    `;

/**
 * __useGetProductQuery__
 *
 * To run a query within a React component, call `useGetProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetProductQuery(baseOptions: Apollo.QueryHookOptions<GetProductQuery, GetProductQueryVariables> & ({ variables: GetProductQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductQuery, GetProductQueryVariables>(GetProductDocument, options);
      }
export function useGetProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductQuery, GetProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductQuery, GetProductQueryVariables>(GetProductDocument, options);
        }
export function useGetProductSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProductQuery, GetProductQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProductQuery, GetProductQueryVariables>(GetProductDocument, options);
        }
export type GetProductQueryHookResult = ReturnType<typeof useGetProductQuery>;
export type GetProductLazyQueryHookResult = ReturnType<typeof useGetProductLazyQuery>;
export type GetProductSuspenseQueryHookResult = ReturnType<typeof useGetProductSuspenseQuery>;
export type GetProductQueryResult = Apollo.QueryResult<GetProductQuery, GetProductQueryVariables>;
export const GetProductByIdDocument = gql`
    query GetProductById($id: ID!) {
  product(id: $id) {
    id
    name
    productType {
      id
      name
    }
    basePrice
    productSelections {
      id
      partOption {
        id
        name
        partCategory {
          id
          name
        }
      }
    }
  }
}
    `;

/**
 * __useGetProductByIdQuery__
 *
 * To run a query within a React component, call `useGetProductByIdQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductByIdQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductByIdQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useGetProductByIdQuery(baseOptions: Apollo.QueryHookOptions<GetProductByIdQuery, GetProductByIdQueryVariables> & ({ variables: GetProductByIdQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductByIdQuery, GetProductByIdQueryVariables>(GetProductByIdDocument, options);
      }
export function useGetProductByIdLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductByIdQuery, GetProductByIdQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductByIdQuery, GetProductByIdQueryVariables>(GetProductByIdDocument, options);
        }
export function useGetProductByIdSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProductByIdQuery, GetProductByIdQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProductByIdQuery, GetProductByIdQueryVariables>(GetProductByIdDocument, options);
        }
export type GetProductByIdQueryHookResult = ReturnType<typeof useGetProductByIdQuery>;
export type GetProductByIdLazyQueryHookResult = ReturnType<typeof useGetProductByIdLazyQuery>;
export type GetProductByIdSuspenseQueryHookResult = ReturnType<typeof useGetProductByIdSuspenseQuery>;
export type GetProductByIdQueryResult = Apollo.QueryResult<GetProductByIdQuery, GetProductByIdQueryVariables>;
export const GetProductsByTypeDocument = gql`
    query GetProductsByType($productType: String!) {
  productsByType(productType: $productType) {
    id
    name
    productType {
      id
      name
    }
    basePrice
  }
}
    `;

/**
 * __useGetProductsByTypeQuery__
 *
 * To run a query within a React component, call `useGetProductsByTypeQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductsByTypeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductsByTypeQuery({
 *   variables: {
 *      productType: // value for 'productType'
 *   },
 * });
 */
export function useGetProductsByTypeQuery(baseOptions: Apollo.QueryHookOptions<GetProductsByTypeQuery, GetProductsByTypeQueryVariables> & ({ variables: GetProductsByTypeQueryVariables; skip?: boolean; } | { skip: boolean; }) ) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>(GetProductsByTypeDocument, options);
      }
export function useGetProductsByTypeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>(GetProductsByTypeDocument, options);
        }
export function useGetProductsByTypeSuspenseQuery(baseOptions?: Apollo.SkipToken | Apollo.SuspenseQueryHookOptions<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>) {
          const options = baseOptions === Apollo.skipToken ? baseOptions : {...defaultOptions, ...baseOptions}
          return Apollo.useSuspenseQuery<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>(GetProductsByTypeDocument, options);
        }
export type GetProductsByTypeQueryHookResult = ReturnType<typeof useGetProductsByTypeQuery>;
export type GetProductsByTypeLazyQueryHookResult = ReturnType<typeof useGetProductsByTypeLazyQuery>;
export type GetProductsByTypeSuspenseQueryHookResult = ReturnType<typeof useGetProductsByTypeSuspenseQuery>;
export type GetProductsByTypeQueryResult = Apollo.QueryResult<GetProductsByTypeQuery, GetProductsByTypeQueryVariables>;